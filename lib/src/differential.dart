import 'package:evolution/evolution.dart';

///
/// Differential Evolution.
///
/// This is an custom version of Differential Evolution.
/// DE is originally due to Storn and Price.

/// public interface
double differential(
  int positions, //
  int sizeN, //
  int bestN, //
  int randN, //
  int diffN, //
  int seed, //
  int steps, //
  double w, //
  double Function(List<double>) fitness, //
) =>
    diff(
      positions, //
      sizeN, //
      bestN, //
      randN, //
      diffN, //
      seed, //
      steps, //
      w,
      fitness,
    ).fitness();

/// A version of Differential Evolution with unrestricted search space.
Agent diff(
  int positions, // number of variables, i.e dimensionality of the problem
  int sizeN, // number of [Agent]s in the population
  int bestN, // number of [Agent]s selected by fitness
  int randN, // number of [Agent]s randomly selected
  int diffN, // number of [Agent]s generated by differential evolution
  int seed, // seeding the random number generator
  int steps, // number of generations
  double w, // weighting factor used in differential evolution
  double Function(List<double>) fitness, // evaluation function
) {
  //int seed = DateTime.now().millisecond;
  Random r = Random(seed);

  int z = 0;
  Population p0 = generatePopulation(
    sizeN,
    positions,
    r,
    fitness,
  );

  while (z < steps) {
    double wz = w / ((z == 0 ? 1 : z)).toDouble();

    /*
    Population p01 = p0.copy();
    p01.shuffle(r.r);
    Population rand = p01.select(randN);
    */

    // best survivors
    Population best = p0.sorted().select(bestN);

    // mutation
    Population mutated = p0.mutation(wz / 10.0);

    // differential operation
    Population differential = mutated.differential(diffN, wz * 10.0);

    // combine subpopulations
    Population all = Population(
        /*rand + */ best + differential,
        r,
        fitness);

    // best survivors of combined population
    Population result = all.sorted().select(sizeN);

    p0 = result;
    z++;
  }
  Population res = p0.sorted().select(1);
  //print(res);
  return res.first;
}

/// A version of Differential Evolution with restricted search space.

Agent diff2(
  int positions, // number of variables, i.e dimensionality of the problem
  int sizeN, // number of [Agent]s in the population
  int bestN, // number of [Agent]s selected by fitness
  int randN, // number of [Agent]s randomly selected
  int diffN, // number of [Agent]s generated by differential evolution
  int seed, // seeding the random number generator
  int steps, // number of generations
  double w, // weighting factor used in differential evolution
  double Function(List<double>) fitness, // evaluation function
  double lower, // lower bound
  double upper, // upper bound
) {
  //int seed = DateTime.now().millisecond;
  Random r = Random(seed);

  int z = 0;
  Population p0 = generatePopulation(
    sizeN,
    positions,
    r,
    fitness,
  );

  while (z < steps) {
    double wz = w / ((z == 0 ? 1 : z)).toDouble();

    /*
    // random survivors
    Population p01 = p0.copy();
    p01.shuffle(r.r);
    Population rand = p01.select(randN);
    */

    // best survivors
    Population best = p0.sorted().select(bestN);

    // mutation
    Population mutated = best.mutation(wz / 10.0).confined(lower, upper);

    // differential operation
    Population differential = mutated.differential(diffN, wz * 10.0);

    // combine subpopulations
    Population all = Population(
        /*rand + */ best + differential,
        r,
        fitness);

    // select best of combined population
    Population result = all.sorted().select(sizeN);

    p0 = result;
    z++;
  }
  Population res = p0.sorted().select(1);
  return res.first;
}
